# SPOD PROM - Система обработки и редактирования данных

## Содержание

1. [Общее описание](#общее-описание)
2. [Структура проекта](#структура-проекта)
3. [Модули src/ (описание и назначение)](#модули-src-описание-и-назначение)
4. [Конфигурация config.json](#конфигурация-configjson)
5. [Программа main.py - Обработка данных](#программа-mainpy---обработка-данных)
6. [Админ-панель - Редактирование данных](#админ-панель---редактирование-данных)
7. [Техническое задание](#техническое-задание)
8. [Анализ входных данных](#анализ-входных-данных)
9. [Установка и запуск](#установка-и-запуск)
10. [Логирование](#логирование)
11. [История версий](#история-версий)

---

## Общее описание

Проект состоит из двух основных компонентов:

1. **main.py** - Основная программа обработки данных из CSV файлов SPOD системы
2. **admin_panel** - Веб-интерфейс для редактирования данных через браузер

Обе программы работают с одними и теми же исходными данными, но выполняют разные задачи:
- `main.py` - читает, обрабатывает, объединяет и записывает данные в Excel
- `admin_panel` - позволяет редактировать данные через удобный веб-интерфейс

---

## Структура проекта

```
SPOD_PROM/
├── main.py                 # Точка входа: загрузка Config, запуск пайплайна (код в src/)
├── config.json             # Конфигурация (пути, файлы, правила merge, цвета, форматы и т.д.)
├── README.md               # Документация проекта (в т.ч. полное описание config.json)
├── src/                    # Исходный код обработки (модули и классы)
│   ├── __init__.py
│   ├── config_loader.py   # Класс Config — загрузка config.json
│   ├── config_holder.py    # Внедрение конфига для main_impl
│   ├── logging_setup.py   # Форматтер логов, настройка логгера
│   ├── json_utils.py      # Разбор и разворот JSON-полей
│   ├── file_loader.py     # Класс FileLoader — поиск/чтение CSV, разворот JSON
│   ├── tournament.py      # Расчёт статуса турнира (CALC_TOURNAMENT_STATUS)
│   ├── validation.py     # Валидация длины полей, проверка дубликатов
│   ├── gender.py         # Определение пола (AUTO_GENDER)
│   └── main_impl.py      # Полный пайплайн: загрузка, merge, summary, Excel, отчёты
├── requirements.txt        # Зависимости (pandas, openpyxl и др.) для main.py
├── SPOD/                   # Исходные CSV файлы (paths.input)
├── OUT/                    # Результирующие Excel файлы (paths.output)
├── EDIT/                   # Копии файлов для редактирования (сессии админ-панели)
├── BACKUP/                 # Резервные копии
├── POST/                   # Копии основных файлов (main.py.txt, README.md.txt, config.json.txt)
├── LOGS/                   # Файлы логов (paths.logs)
├── Docs/                   # Дополнительная документация (.md, .txt)
├── admin_panel/            # Админ-панель
│   ├── app.py             # Flask приложение
│   ├── config.py          # Конфигурация
│   ├── templates/         # HTML шаблоны
│   ├── static/            # CSS, JS, изображения
│   └── utils/             # Утилиты
│       ├── file_manager.py
│       ├── data_manager.py
│       └── json_editor.py
└── venv/                  # Виртуальное окружение
```

---

## Модули src/ (описание и назначение)

Исходный код обработки данных вынесен в каталог **src/**; корневой **main.py** только загружает конфигурацию и запускает пайплайн.

| Модуль | Назначение | Основные сущности |
|--------|------------|-------------------|
| **config_loader.py** | Загрузка и хранение настроек из config.json | Класс `Config`: атрибуты `dir_input`, `dir_output`, `dir_logs`, `input_files`, `summary_sheet`, `sheet_order`, `summary_key_defs`, `summary_key_columns`, `gender_patterns`, `gender_progress_step`, `field_length_validations`, `merge_fields_advanced`, `color_scheme`, `column_formats`, `check_duplicates`, `json_columns`, `max_workers_io`, `max_workers_cpu`, `tournament_status_choices`; метод `get_output_filename()`. |
| **config_holder.py** | Внедрение текущего конфига для кода, работающего с глобальными переменными | `set_current_config(config)`, `get_current_config()`. |
| **logging_setup.py** | Настройка логирования | Класс `CallerFormatter` (добавляет имя функции в сообщение); функция `setup_logger(config)` — возвращает путь к лог-файлу, настраивает вывод в файл (DEBUG) и консоль (INFO). |
| **json_utils.py** | Разбор и разворот JSON-полей в DataFrame | `safe_json_loads(s)` — парсинг строки в JSON с поправкой типичных ошибок; `safe_json_loads_preserve_triple_quotes(s)`; `flatten_json_column_recursive(df, column, prefix=..., sheet=..., sep=..., max_workers_io=...)` — рекурсивный разворот колонки в несколько колонок, при большом объёме — параллельно. |
| **file_loader.py** | Поиск и загрузка CSV, разворот JSON по конфигу | Класс `FileLoader(config)`: `find_file_case_insensitive(directory, base_name, extensions)`, `check_input_files_exist()`, `read_csv_file(file_path)`, `process_single_file(file_conf)` — возвращает `(df, sheet_name, file_conf)` или `(None, sheet_name, None)`. |
| **tournament.py** | Расчёт статуса турнира по датам | `calculate_tournament_status(config, df_tournament, df_report=None)` — добавляет колонку `CALC_TOURNAMENT_STATUS` по правилам из `config.tournament_status_choices`. |
| **validation.py** | Валидация длины полей и проверка дубликатов | `validate_field_lengths(config, df, sheet_name)`, `validate_field_lengths_vectorized(config, df, sheet_name)`, `compare_validate_results(df_old, df_new, result_column)`, `mark_duplicates(df, key_cols, sheet_name=...)`, `validate_single_sheet(config, sheet_name, sheets_data_item)`, `check_duplicates_single_sheet(config, sheet_name, sheets_data_item)`. |
| **gender.py** | Определение пола по отчеству, имени, фамилии | `add_auto_gender_column(config, df, sheet_name)`, `add_auto_gender_column_vectorized(config, df, sheet_name)`, `compare_gender_results(df_old, df_new)`. Внутри используются паттерны из `config.gender_patterns`. |
| **main_impl.py** | Полный пайплайн обработки | При импорте вызывается `_load_config_globals()` (из config.json или из внедрённого Config). Функция `main()`: проверка наличия файлов → параллельная загрузка CSV и разворот JSON → добавление AUTO_GENDER (EMPLOYEE) → валидация длины полей → расчёт статуса турнира → merge (кроме SUMMARY) → проверка дубликатов → формирование SUMMARY → лист STAT_FILE → запись Excel → итоговый отчёт по дубликатам и валидации. Остальные функции (merge, summary, Excel, отчёты) реализованы в этом же модуле. |

**Запуск:** из корня проекта выполняется `python main.py`. При этом создаётся `Config()` (путь к config.json — корень проекта), конфиг передаётся в `set_current_config(config)`, затем вызывается `main_impl.main()`. В начале `main_impl.main()` снова вызывается `_load_config_globals()`, поэтому все глобальные переменные в main_impl берутся из внедрённого конфига.

---

## Конфигурация config.json

Все параметры обработки данных задаются в файле **config.json** в корне проекта. Программа `main.py` при запуске загружает конфиг и использует его значения. Изменение настроек не требует правки кода.

### Полный перечень секций config.json

| Секция | Назначение |
|--------|------------|
| `paths` | Каталоги: вход (SPOD), выход (OUT), логи (LOGS). |
| `logging` | Уровень (INFO/DEBUG) и базовое имя файла логов. |
| `performance` | Количество потоков: max_workers_io, max_workers_cpu. |
| `tournament_status_choices` | Подписи статусов турнира (расчёт CALC_TOURNAMENT_STATUS). |
| `input_files` | Список CSV-файлов и параметров листов Excel (имя файла, лист, ширина колонок, freeze). |
| `summary_sheet` | Параметры сводного листа SUMMARY (ширина, закрепление). |
| `sheet_order` | Порядок листов в выходном Excel (если задан). |
| `summary_key_defs` | Ключевые колонки по листам для каркаса SUMMARY (порядок колонок). |
| `gender` | Правила автоопределения пола (паттерны отчества/имени/фамилии). |
| `field_length_validations` | Проверка длины полей по листам (result_column, fields с limit и operator). |
| `derived_columns` | Производные колонки: добавление на лист колонки с преобразованием (например, pad_left — табельный в 20 знаков с лидирующими нулями). |
| `merge_fields_advanced` | Правила переноса/подсчёта полей между листами (источник, приёмник, ключи, column, mode, src_key_transforms, dst_key_transforms). |
| `color_scheme` | Цвета заголовков и ячеек по листам и колонкам. |
| `column_formats` | Формат ячеек: число, дата, выравнивание по листам и колонкам. |
| `check_duplicates` | Правила поиска дубликатов по ключу (лист, key). |
| `json_columns` | Колонки с JSON для разворота по листам (column, prefix). |

### Общая структура файла

```json
{
  "paths": { ... },
  "logging": { ... },
  "performance": { ... },
  "tournament_status_choices": [ ... ],
  "input_files": [ ... ],
  "summary_sheet": { ... },
  "summary_key_defs": [ ... ],
  "gender": { ... },
  "field_length_validations": { ... },
  "derived_columns": [ ... ],
  "merge_fields_advanced": [ ... ],
  "color_scheme": [ ... ],
  "column_formats": [ ... ],
  "check_duplicates": [ ... ],
  "json_columns": { ... }
}
```

---

### paths

**Назначение:** относительные имена каталогов для входных данных, выходного Excel и логов. Пути собираются программой как `(каталог_программы)/(значение)`.

| Ключ     | Тип   | Описание |
|----------|--------|----------|
| `input`  | строка | Каталог с CSV-файлами (по умолчанию `"SPOD"`). |
| `output` | строка | Каталог для сгенерированных xlsx (по умолчанию `"OUT"`). |
| `logs`   | строка | Каталог для лог-файлов (по умолчанию `"LOGS"`). |

**Пример:**
```json
"paths": {
  "input": "SPOD",
  "output": "OUT",
  "logs": "LOGS"
}
```

**Логика:** при старте программа формирует, например, `DIR_INPUT = os.path.join(BASE_DIR, paths.input)`. Файлы ищутся в `SPOD/`, результат пишется в `OUT/`, логи — в `LOGS/`.

---

### logging

**Назначение:** настройки логирования.

| Ключ        | Тип   | Описание |
|-------------|--------|----------|
| `level`     | строка | Уровень логгера: `"INFO"` (обычная работа) или `"DEBUG"` (подробный вывод в файл). |
| `base_name` | строка | Базовое имя лог-файла; к нему добавляются уровень и дата/время (например, `LOGS_INFO_20260204_22_30.log`). |

**Пример:**
```json
"logging": {
  "level": "INFO",
  "base_name": "LOGS"
}
```

**Логика:** имя файла лога: `{base_name}_{level}_{YYYYMMDD}_{HH_MM}.log` в каталоге `paths.logs`. Консоль получает только INFO и выше; в файл при `DEBUG` пишется всё.

---

### performance

**Назначение:** число потоков для параллельных операций.

| Ключ             | Тип    | Описание |
|------------------|--------|----------|
| `max_workers_io` | число  | Потоки для I/O: чтение CSV, подготовка к записи в Excel. Рекомендуется 8–16. |
| `max_workers_cpu` | число | Потоки для CPU: проверка длины полей, дубликатов и т.п. Обычно до числа ядер. |

**Пример:**
```json
"performance": {
  "max_workers_io": 16,
  "max_workers_cpu": 8
}
```

**Логика:** чтение файлов и разворот JSON идут в пуле с `max_workers_io`; проверки валидации и дубликатов — с `max_workers_cpu`. Слишком большие значения могут замедлить из-за накладных расходов.

---

### tournament_status_choices

**Назначение:** подписи статусов турнира для расчётной колонки `CALC_TOURNAMENT_STATUS`. Порядок элементов строго соответствует условиям 0–6 в `calculate_tournament_status`.

| Индекс | Условие (кратко) | Типичное значение |
|--------|-------------------|-------------------|
| 0 | Нет ключевых дат | `"НЕОПРЕДЕЛЕН"` |
| 1 | Сегодня между START_DT и END_DT | `"АКТИВНЫЙ"` |
| 2 | Сегодня &lt; START_DT | `"ЗАПЛАНИРОВАН"` |
| 3–5 | Разные варианты после END_DT / RESULT_DT | `"ПОДВЕДЕНИЕ ИТОГОВ"` |
| 6 | Все конкурсы завершены | `"ЗАВЕРШЕН"` |

**Пример:**
```json
"tournament_status_choices": [
  "НЕОПРЕДЕЛЕН",
  "АКТИВНЫЙ",
  "ЗАПЛАНИРОВАН",
  "ПОДВЕДЕНИЕ ИТОГОВ",
  "ПОДВЕДЕНИЕ ИТОГОВ",
  "ПОДВЕДЕНИЕ ИТОГОВ",
  "ЗАВЕРШЕН"
]
```

**Логика:** по датам (START_DT, END_DT, RESULT_DT, MAX_CONTEST_DATE) выбирается одно из условий; в ячейку записывается строка из массива с тем же индексом. Смена формулировок (например, «ЗАВЕРШЕН» → «ЗАВЕРШЁН») делается только в конфиге.

---

### input_files

**Назначение:** список CSV-файлов и настроек листов Excel. Каждый элемент описывает один файл и один лист в итоговой книге.

| Ключ            | Тип    | Описание |
|-----------------|--------|----------|
| `file`          | строка | Имя CSV (с расширением или без). Поиск в каталоге `paths.input` без учёта регистра (.csv / .CSV). |
| `sheet`         | строка | Имя листа в выходном Excel, куда попадут данные этого файла. |
| `max_col_width` | число  | Максимальная ширина колонки (символов) при авто-ширине. |
| `freeze`        | строка | Закрепление областей, например `"C2"` — закрепить столбцы A–B и строку 1. |
| `col_width_mode`| строка | Режим ширины: `"AUTO"` — по содержимому (ограничено max_col_width), либо число — фиксированная ширина. |
| `min_col_width` | число  | Минимальная ширина колонки. |

**Пример:**
```json
{
  "file": "CONTEST (PROM) 02-02 v2.csv",
  "sheet": "CONTEST-DATA",
  "max_col_width": 120,
  "freeze": "C2",
  "col_width_mode": "AUTO",
  "min_col_width": 12
}
```

**Логика:** программа перебирает `input_files`, для каждого ищет файл в `SPOD/`, читает CSV, разворачивает JSON по правилам из `json_columns`, затем записывает лист с именем `sheet` и применяет к нему указанные ширины и закрепление.

---

### summary_sheet

**Назначение:** параметры сводного листа «SUMMARY» (имя листа, ширина колонок, закрепление).

| Ключ            | Тип    | Описание |
|-----------------|--------|----------|
| `sheet`         | строка | Имя листа (обычно `"SUMMARY"`). |
| `max_col_width` | число  | Максимальная ширина колонки. |
| `freeze`        | строка | Закрепление (например `"G2"`). |
| `col_width_mode`| строка | Режим ширины колонок. |
| `min_col_width` | число  | Минимальная ширина. |

**Логика:** сводный лист строится по правилам `merge_fields_advanced` (где `sheet_dst` = имя из `summary_sheet.sheet`), затем к нему применяются эти параметры форматирования.

---

### sheet_order

**Назначение:** порядок листов в выходном Excel. Если параметр задан (непустой массив), листы выводятся в указанном порядке; листы, не перечисленные в списке, добавляются следом в алфавитном порядке. Если параметр отсутствует или пуст — используется порядок по умолчанию: SUMMARY первым, остальные по алфавиту.

| Ключ | Тип | Описание |
|------|-----|----------|
| (массив) | строки | Имена листов в нужном порядке (например, `"SUMMARY"`, `"STAT_FILE"`, `"CONTEST-DATA"`, …). |

**Пример:**
```json
"sheet_order": ["SUMMARY", "STAT_FILE", "CONTEST-DATA", "GROUP", "INDICATOR", "REPORT", "REWARD", "REWARD-LINK", "TOURNAMENT-SCHEDULE"]
```

**Логика:** при записи в Excel сначала выводятся листы из `sheet_order`, присутствующие в `sheets_data`; затем все оставшиеся листы в отсортированном по имени порядке.

---

### summary_key_defs

**Назначение:** определение ключевых колонок по листам для построения «каркаса» сводного листа. Из этих определений программа собирает упорядоченный список всех уникальных ключей (`SUMMARY_KEY_COLUMNS`).

| Ключ   | Тип   | Описание |
|--------|--------|----------|
| `sheet`| строка | Имя листа (как в `input_files.sheet`). |
| `cols` | массив строк | Список колонок, образующих составной ключ для этого листа. |

**Пример:**
```json
{"sheet": "CONTEST-DATA", "cols": ["CONTEST_CODE"]},
{"sheet": "GROUP", "cols": ["GROUP_CODE", "CONTEST_CODE", "GROUP_VALUE"]}
```

**Логика:** из всех `cols` собирается уникальный упорядоченный список колонок. Сводный лист строится по комбинациям этих ключей, затем к строкам подтягиваются поля по правилам `merge_fields_advanced` с `sheet_dst: "SUMMARY"`.

---

### gender

**Назначение:** правила автоматического определения пола по отчеству, имени и фамилии (колонка `AUTO_GENDER` на листе EMPLOYEE).

| Ключ            | Тип  | Описание |
|-----------------|------|----------|
| `patterns`      | объект | Словарь списков окончаний для отчества, имени и фамилии (муж./жен.). |
| `progress_step` | число | Раз в сколько строк выводить прогресс в лог (например, 500). |

Ключи внутри `patterns`:

- `patronymic_male`, `patronymic_female` — окончания отчеств (например, «ович», «овна»).
- `name_male`, `name_female` — окончания имён.
- `surname_male`, `surname_female` — окончания фамилий.

**Пример (фрагмент):**
```json
"gender": {
  "patterns": {
    "patronymic_male": ["ович", "евич", "ич", "ыч", "оглы", "улы", "уулу", "заде"],
    "patronymic_female": ["овна", "евна", "инична", "ична", "на", "кызы"],
    "name_male": ["ий", "ей", "ай", "ой", "ый", "ев", "ов", "ин", "ан", "он", "ен", "ур", "ич", "ыч"],
    "name_female": ["а", "я", "ина", "ана", "ена", "ия", "ья", "на", "ла", "ра", "са", "та", "да", "ка", "га"],
    "surname_male": ["ов", "ев", "ин", "ын", "ский", "цкий", "ич", "енко", "ко", "як", "ук", "юк", "ич", "ыч"],
    "surname_female": ["ова", "ева", "ина", "ына", "ская", "цкая", "енко", "ко"]
  },
  "progress_step": 500
}
```

**Логика:** приоритет — отчество → имя → фамилия. Значение приводится к нижнему регистру и проверяется на окончание из соответствующего списка; при совпадении выставляется «М» или «Ж», иначе «-». Векторизованная версия использует те же списки.

---

### field_length_validations

**Назначение:** проверка длины полей на указанных листах. Для каждого листа задаётся результирующая колонка и правила по полям (лимит и оператор сравнения).

Структура: объект, ключи — имена листов (`"ORG_UNIT_V20"`, `"EMPLOYEE"`, `"REPORT"` и т.д.). Значение — объект:

| Ключ            | Тип   | Описание |
|-----------------|--------|----------|
| `result_column` | строка | Имя колонки с результатом проверки (например, `"FIELD_LENGTH_CHECK"`). |
| `fields`        | объект | Имя поля → правило: `{"limit": N, "operator": "=" \| "<=" \| ">="}`. |

**Пример:**
```json
"field_length_validations": {
  "EMPLOYEE": {
    "result_column": "FIELD_LENGTH_CHECK",
    "fields": {
      "PERSON_NUMBER": { "limit": 20, "operator": "=" },
      "PERSON_NUMBER_ADD": { "limit": 20, "operator": "=" }
    }
  }
}
```

**Логика:** для каждой строки листа проверяется длина указанных полей. Если длина не соответствует правилу (например, не равна 20 при `operator: "="`), в `result_column` записывается признак ошибки; иначе — «-». В конце работы программа выводит в лог и в консоль сводку по отклонениям (лист, колонка результата, количество строк с отклонениями, примеры); работа при этом не прерывается.

---

### derived_columns

**Назначение:** добавление на лист производной колонки с преобразованием (например, приведение табельного номера к 20 знакам с лидирующими нулями). Выполняется до merge, чтобы новую колонку можно было использовать в ключах правил merge_fields_advanced.

| Ключ             | Тип    | Описание |
|------------------|--------|----------|
| `sheet`          | строка | Имя листа. |
| `source_column`  | строка | Исходная колонка. |
| `target_column`  | строка | Имя новой колонки. |
| `transform`      | строка | Тип преобразования: `"pad_left"` — дополнение слева нулями до заданной длины. |
| `length`         | число  | Для pad_left — целевая длина (например, 20). |

**Пример:**
```json
"derived_columns": [
  {
    "sheet": "LIST-REWARDS",
    "source_column": "Табельный номер сотрудника",
    "target_column": "PERSON_NUMBER_20",
    "transform": "pad_left",
    "length": 20
  }
]
```

**Логика:** перед merge для каждого правила создаётся колонка `target_column` на листе `sheet`; значение берётся из `source_column` и преобразуется (pad_left — строка с лидирующими нулями). В merge в `src_key` можно указать `target_column`.

---

### merge_fields_advanced

**Назначение:** правила переноса и подсчёта полей между листами (объединение данных). Каждое правило задаёт источник, приёмник, ключи и список полей.

Основные поля одного правила:

| Ключ               | Тип    | Описание |
|--------------------|--------|----------|
| `sheet_src`        | строка | Лист-источник данных. |
| `sheet_dst`        | строка | Лист, куда добавляются поля. |
| `src_key`         | массив строк | Ключ(и) в источнике (например, `["CONTEST_CODE"]`). |
| `dst_key`         | массив строк | Ключ(и) в приёмнике (часто те же имена или составной ключ, например `["REWARD_LINK => CONTEST_CODE"]`). |
| `column`          | массив строк | Поля для переноса или имя поля для подсчёта (при `mode: "count"`). |
| `mode`            | строка | `"value"` — подтянуть значения; `"count"` — подсчитать количество совпадений. |
| `multiply_rows`   | bool   | При нескольких совпадениях по ключу: размножить строки в приёмнике (true) или взять одно значение (false). |
| `col_max_width`, `col_width_mode`, `col_min_width` | | Параметры ширины добавляемых колонок в Excel. |
| `status_filters`  | объект или null | Фильтр по полям в источнике (например, только `BUSINESS_STATUS` из списка). |
| `custom_conditions`, `group_by`, `aggregate` | | Доп. условия, группировка, агрегация (если используются). |
| `count_aggregation`| строка | Для `mode: "count"`: `"size"` или `"nunique"`. |
| `count_label`     | строка или null | Суффикс имени колонки счётчика (например, `"ACTIVE"` → колонка `COUNT_..._ACTIVE`). |
| `src_key_transforms` | объект или null | Преобразование ключей источника перед связью: колонка → строка `"pad_20"` (привести к 20 знакам с лидирующими нулями). |
| `dst_key_transforms` | объект или null | Преобразование ключей приёмника перед связью: колонка → `"pad_20"` (чтобы совпадать с форматом источника). |

**Пример (подтягивание значений):**
```json
{
  "sheet_src": "CONTEST-DATA",
  "sheet_dst": "REPORT",
  "src_key": ["CONTEST_CODE"],
  "dst_key": ["CONTEST_CODE"],
  "column": ["CONTEST_TYPE", "FULL_NAME", "BUSINESS_STATUS", "BUSINESS_BLOCK", "TARGET_TYPE", "CONTEST_FEATURE => vid"],
  "mode": "value",
  "multiply_rows": false,
  "status_filters": { "BUSINESS_STATUS": ["АКТИВНЫЙ", "ПОДВЕДЕНИЕ ИТОГОВ"] }
}
```

**Пример (подсчёт):**
```json
{
  "sheet_src": "REPORT",
  "sheet_dst": "SUMMARY",
  "src_key": ["TOURNAMENT_CODE"],
  "dst_key": ["TOURNAMENT_CODE"],
  "column": ["CONTEST_DATE"],
  "mode": "count",
  "count_aggregation": "size",
  "count_label": null
}
```

**Логика:** для каждой строки листа-приёмника по `dst_key` ищутся строки в источнике по `src_key`; при `mode: "value"` подставляются значения из `column` (при нескольких совпадениях поведение задаётся `multiply_rows`); при `mode: "count"` в приёмник записывается количество (size или nunique). Если задан `src_key_transform`, перед связью значения указанных колонок источника преобразуются (например, табельный номер — к 20 символам с лидирующими нулями), чтобы совпадать с форматом на приёмнике. Поля с префиксом вида `CONTEST_FEATURE => vid` — это развёрнутые JSON-поля (имя после `=>` — ключ внутри JSON).

**Пример (count по составному ключу с преобразованием табельного к 20 знакам):**
```json
{
  "sheet_src": "LIST-REWARDS",
  "sheet_dst": "REPORT",
  "src_key": ["Код турнира", "Табельный номер сотрудника"],
  "dst_key": ["TOURNAMENT_CODE", "MANAGER_PERSON_NUMBER"],
  "src_key_transform": {
    "Табельный номер сотрудника": { "type": "pad_left_zeros", "width": 20 }
  },
  "column": ["Код турнира"],
  "mode": "count",
  "count_aggregation": "size",
  "count_label": "REWARDS"
}
```

---

### color_scheme

**Назначение:** цветовое оформление заголовков (и при необходимости ячеек) листов Excel. Каждый элемент задаёт группу стилей, список листов и список колонок.

| Ключ         | Тип   | Описание |
|--------------|--------|----------|
| `group`      | строка | Название группы (для справки). |
| `header_bg`  | строка | Цвет фона заголовка (HEX без решётки, например `"E6F3FF"`). |
| `header_fg`  | строка | Цвет текста заголовка (HEX). |
| `column_bg`, `column_fg` | строка или null | Фон и текст для ячеек данных (если заданы). |
| `style_scope`| строка | `"header"` — стиль только для первой строки. |
| `sheets`     | массив строк | Имена листов, к которым применяется правило. |
| `columns`    | массив строк | Список колонок (заголовков). Пустой массив — все колонки листа. |

**Пример:**
```json
{
  "group": "Исходные данные",
  "header_bg": "E6F3FF",
  "header_fg": "2C3E50",
  "column_bg": null,
  "column_fg": null,
  "style_scope": "header",
  "sheets": ["CONTEST-DATA", "GROUP", "INDICATOR", "REPORT", "REWARD", "REWARD-LINK", "TOURNAMENT-SCHEDULE", "ORG_UNIT_V20", "USER_ROLE", "USER_ROLE SB", "EMPLOYEE"],
  "columns": []
}
```

**Логика:** при формировании Excel для каждого листа из `sheets` к заголовкам (и при необходимости к ячейкам) из `columns` применяется заливка и цвет шрифта. Порядок правил важен: последующие могут перекрывать предыдущие для тех же колонок.

---

### column_formats

**Назначение:** формат ячеек Excel по листам и колонкам (число, дата, выравнивание, перенос).

Каждый элемент — объект:

| Ключ                 | Тип    | Описание |
|----------------------|--------|----------|
| `sheet`              | строка | Имя листа. |
| `columns`            | массив строк | Имена колонок (заголовков). |
| `data_type`          | строка | `"number"`, `"date"` или `"text"`. |
| `decimal_places`     | число  | Для числа — знаков после запятой (0 — целые). |
| `decimal_separator`  | строка | Разделитель дробной части: `","` или `"."`. |
| `thousands_separator`| bool   | Разделитель разрядов в целой части. |
| `date_format`        | строка | Для даты: например `"YYYY-MM-DD"` или `"DD/MM/YYYY"`. |
| `horizontal`, `vertical` | строка | Выравнивание: `"left"`/`"center"`/`"right"`, `"top"`/`"center"`/`"bottom"`. |
| `wrap_text`          | bool   | Перенос по словам. |

**Пример:**
```json
{
  "sheet": "INDICATOR",
  "columns": ["N", "CALC_TYPE", "INDICATOR_WEIGHT", "INDICATOR_CALC_TYPE"],
  "data_type": "number",
  "decimal_places": 0,
  "decimal_separator": ",",
  "thousands_separator": false,
  "date_format": "YYYY-MM-DD",
  "horizontal": "center",
  "vertical": "center",
  "wrap_text": false
}
```

**Логика:** при записи в Excel данные в указанных колонках приводятся к числу или дате (в т.ч. замена запятой на точку при парсе); в книге задаётся числовой/датовый формат и выравнивание. Для `decimal_places: 0` в ячейку записываются целые числа без дробной части.

---

### check_duplicates

**Назначение:** правила поиска дубликатов по ключу на заданных листах. Для каждой комбинации ключа добавляется колонка вида «ДУБЛЬ: KEY1_KEY2_...» с признаком дубля.

| Ключ   | Тип   | Описание |
|--------|--------|----------|
| `sheet`| строка | Имя листа. |
| `key`  | массив строк | Список колонок, по которым определяется дубликат. |

**Пример:**
```json
{"sheet": "CONTEST-DATA", "key": ["CONTEST_CODE"]},
{"sheet": "GROUP", "key": ["CONTEST_CODE", "GROUP_CODE", "GROUP_VALUE"]},
{"sheet": "EMPLOYEE", "key": ["PERSON_NUMBER"]},
{"sheet": "EMPLOYEE", "key": ["PERSON_NUMBER_ADD"]}
```

**Логика:** для листа по полям `key` считается количество повторений комбинации; если больше 1, в новой колонке «ДУБЛЬ: ...» ставится признак дубликата. Одна запись в конфиге — одна такая колонка (на одном листе может быть несколько правил с разными ключами). В конце работы программа выводит в лог и в консоль итоговую статистику: на каком листе найден дубликат, по какому ключу, задублированные значения и количество вхождений; работа при этом не прерывается.

---

### json_columns

**Назначение:** какие колонки в каких листах считать JSON и разворачивать в отдельные колонки. Задаётся по имени листа.

Структура: объект, ключи — имена листов. Значение — массив объектов:

| Ключ    | Тип   | Описание |
|---------|--------|----------|
| `column`| строка | Имя колонки с JSON-строкой. |
| `prefix`| строка | Префикс для имён новых колонок (например, `"CONTEST_FEATURE"` или `"ADD_DATA"`). Вложенные ключи дают имена вида `prefix => key` или `prefix => key => nested`. |

**Пример:**
```json
"json_columns": {
  "CONTEST-DATA": [
    { "column": "CONTEST_FEATURE", "prefix": "CONTEST_FEATURE" }
  ],
  "REWARD": [
    { "column": "REWARD_ADD_DATA", "prefix": "ADD_DATA" }
  ]
}
```

**Логика:** при загрузке листа каждая указанная колонка парсится как JSON; ключи верхнего уровня становятся колонками `prefix => key`; вложенные объекты/массивы разворачиваются рекурсивно с тем же префиксом. Исходная колонка сохраняется; при необходимости тройные кавычки в исходных данных обрабатываются отдельно (CONTEST_FEATURE).

---

## Программа main.py - Обработка данных

### Назначение

Основная программа для обработки данных из CSV файлов системы SPOD. Состоит из двух частей:

1. **Корневой main.py** — точка входа: создаёт экземпляр `Config` (загрузка **config.json** из корня проекта), передаёт его в `config_holder`, затем вызывает `main_impl.main()`.
2. **src/main_impl.py** — полный пайплайн: при запуске подхватывает внедрённый конфиг (или при прямом запуске загружает config.json из корня проекта), настраивает логирование, читает CSV из каталога `paths.input` (по умолчанию `SPOD/`), обрабатывает данные по правилам объединения (`merge_fields_advanced`), проверяет дубликаты (`check_duplicates`) и длину полей, формирует сводный лист SUMMARY и лист STAT_FILE, записывает итоговый Excel и выводит отчёт. Логирование ведётся в файл (уровень DEBUG) и в консоль (INFO).

### Входные данные

Программа работает с CSV-файлами, перечисленными в `config.json` в секции **input_files** (имя файла и листа для каждого источника). Примеры листов:

1. **CONTEST-DATA** - Данные о конкурсах
2. **EMPLOYEE** - Данные о сотрудниках
3. **GROUP** - Группы
4. **INDICATOR** - Индикаторы
5. **ORG_UNIT_V20** - Организационные единицы
6. **REPORT** - Отчеты
7. **REWARD** - Награды
8. **REWARD-LINK** - Связи наград
9. **TOURNAMENT-SCHEDULE** - Расписание турниров
10. **TOURNAMENT-SCHEDULE-LINK** - Связи расписания
11. **TOURNAMENT-SCHEDULE-LINK_CONTEST** - Связи расписания с конкурсами

### Основная логика работы

#### 1. Инициализация и настройка

При запуске из корня (`python main.py`):

```python
# main.py (корень)
config = Config()                    # Загрузка config.json из корня проекта
set_current_config(config)           # Внедрение для main_impl
main_impl.main()                     # Запуск пайплайна
```

Внутри `main_impl.main()` сначала вызывается `_load_config_globals()` — глобальные переменные (DIR_INPUT, INPUT_FILES, MERGE_FIELDS_ADVANCED и т.д.) заполняются из внедрённого Config. Затем настраивается логирование (`setup_logger()` — использует `logging.level` и `logging.base_name` из конфига): DEBUG в файл, INFO в консоль.

#### 2. Чтение CSV файлов

Чтение выполняется в **main_impl**: поиск файла без учёта регистра (`find_file_case_insensitive`), чтение CSV с разделителем `;`, кодировка UTF-8, все ячейки как строки. Аналогичная логика вынесена в класс **FileLoader** в `src/file_loader.py` (методы `read_csv_file`, `process_single_file` с разворотом JSON по `json_columns`).

**Особенности:**
- Поиск файла в каталоге `paths.input` по имени без учёта регистра (.csv / .CSV).
- Для LIST-TOURNAMENT при отсутствии файла с суффиксом `-2` используется альтернативное имя без суффикса.

#### 3. Обработка данных

##### 3.1. Объединение данных (merge_fields_advanced)

Программа объединяет данные из разных файлов по правилам из **config.json** → `merge_fields_advanced`. Каждое правило задаёт источник, приёмник, ключи и поля (подробнее см. раздел [Конфигурация config.json](#конфигурация-configjson) → merge_fields_advanced).

```json
{
  "sheet_src": "SOURCE_SHEET",
  "sheet_dst": "DEST_SHEET",
  "src_key": ["SOURCE_KEY"],
  "dst_key": ["DEST_KEY"],
  "column": ["FIELD1", "FIELD2"],
  "mode": "value",
  "multiply_rows": false
}
```

**Режимы объединения:**
- `merge` - Объединение полей (добавление новых колонок)
- `count` - Подсчет количества записей
- `sum` - Суммирование значений

##### 3.2. Проверка дубликатов (check_duplicates из config.json)

Правила задаются в **config.json** в секции `check_duplicates`. Каждый элемент: `"sheet"` — имя листа, `"key"` — массив колонок для проверки.

**Логика:**
- Находит записи с одинаковыми значениями в ключевых колонках
- Добавляет колонку «ДУБЛЬ: KEY1_KEY2_...» с меткой (например, «x2») при повторении комбинации ключа
- В конце работы выводит сводку по дубликатам в лог и консоль (лист, ключ, задублированные значения)

##### 3.3. Обработка JSON полей

Некоторые поля содержат JSON данные:
- `CONTEST_FEATURE` (CONTEST-DATA)
- `CONTEST_PERIOD` (CONTEST-DATA)
- `BUSINESS_BLOCK` (CONTEST-DATA)
- `TARGET_TYPE` (TOURNAMENT-SCHEDULE)
- `FILTER_PERIOD_ARR` (TOURNAMENT-SCHEDULE)
- `INDICATOR_FILTER` (INDICATOR)
- `GROUP_VALUE` (GROUP)
- `REWARD_ADD_DATA` (REWARD)

Эти поля обрабатываются как строки и сохраняются в исходном виде.

#### 4. Запись в Excel

```python
def write_to_excel(sheets_data, output_path):
    # Создает Excel файл с несколькими листами
    # Сохраняет порядок листов
    # Применяет цветовую схему для дубликатов
```

**Структура Excel файла:**
- Каждый исходный файл → отдельный лист
- Листы упорядочены согласно `ordered_sheets`
- Применяется цветовая схема для дубликатов

#### 5. Итоговая статистика (дубликаты и валидация длины полей)

После записи в Excel программа формирует отчёт и выводит его **в лог и в консоль** (без прерывания работы):

- **Дубликаты** (по правилам `check_duplicates`): для каждого листа, где найдены дубликаты — имя листа, ключ (колонки), имя колонки проверки, число строк с дубликатами, задублированные значения ключей и количество вхождений.
- **Отклонения по длине полей** (по правилам `field_length_validations`): для каждого листа с нарушениями — имя листа, колонка результата, число строк с отклонениями, примеры текста нарушений (до 10).

Функции: `collect_duplicates_and_validation_report(sheets_data)` — сбор данных; `print_final_report(duplicates_report, validation_report)` — вывод в лог и консоль.

#### 6. Лист STAT_FILE (статистика по файлам)

После формирования SUMMARY программа создаёт лист **STAT_FILE** с общей статистикой по исходным CSV-файлам. Для каждого файла из `input_files` выводится: имя файла (`FILE_NAME`), имя листа (`SHEET_NAME`), дата изменения файла (`FILE_DATE`), дата обработки (`DATA_UPDATE_DATE`), количество записей (`ROW_COUNT`), количество колонок (`COL_COUNT`), размер файла в байтах (`FILE_SIZE_BYTES`), статус загрузки (`STATUS`: OK / не найден). Лист добавляется в `sheets_data` и выводится в Excel в порядке, заданном в `sheet_order` (по умолчанию — сразу после SUMMARY).

### Логирование

Программа ведет два уровня логирования:

1. **DEBUG** (в файл):
   - Все операции чтения/записи
   - Детали обработки данных
   - Ошибки с полным stack trace
   - Формат: `дата время - [DEBUG] - сообщение [class: ClassName | def: function_name]`

2. **INFO** (в консоль):
   - Основные этапы выполнения
   - Критические ошибки
   - Итоговая статистика

**Именование логов:**
- Формат: `LOGS_DEBUG_YYYYMMDD_HH_MM.log`
- Расположение: `LOGS/`

---

## Админ-панель - Редактирование данных

### Назначение

Веб-интерфейс для редактирования данных из CSV файлов через браузер. Позволяет:
- Просматривать данные всех файлов
- Редактировать записи
- Создавать новые записи
- Удалять записи
- Редактировать JSON поля
- Работать с несколькими сессиями редактирования

### Архитектура

#### Backend (Flask)

**app.py** - Основное Flask приложение:
- REST API для работы с данными
- Управление сессиями редактирования
- Обработка CRUD операций

**Основные endpoints:**
```
GET  /api/sessions              # Список сессий
POST /api/session/new           # Создание новой сессии
POST /api/session/<name>        # Переключение сессии
DELETE /api/session/<name>      # Удаление сессии
GET  /api/files                  # Список файлов
GET  /api/files/<key>/records   # Записи файла
GET  /api/files/<key>/records/<id>  # Одна запись
POST /api/files/<key>/records   # Создание записи
PUT  /api/files/<key>/records/<id>   # Обновление записи
DELETE /api/files/<key>/records/<id> # Удаление записи
```

**config.py** - Конфигурация:
- Динамическое чтение `INPUT_FILES` из `main.py`
- Определение JSON полей
- Зависимости между файлами
- Многострочные поля

**utils/file_manager.py** - Управление файлами:
- Чтение/запись CSV
- Управление сессиями (создание, удаление)
- Резервное копирование

**utils/data_manager.py** - Управление данными:
- CRUD операции
- Валидация данных
- Обработка JSON полей
- Проверка зависимостей

#### Frontend (HTML/CSS/JavaScript)

**templates/index.html** - Главная страница:
- Интерфейс с вкладками для файлов
- Формы редактирования
- Модальные окна для JSON редактора

**static/js/app.js** - Клиентская логика:
- Загрузка и отображение данных
- Управление сессиями
- CRUD операции через API
- JSON редактор

**static/css/style.css** - Стили:
- Современный дизайн
- Адаптивная верстка
- Цветовая схема

### Логика работы админ-панели

#### 1. Инициализация

При загрузке страницы:
1. Загружается список сессий из `EDIT/`
2. Выбирается последняя сессия (или создается новая)
3. Загружается список файлов из `main.py`
4. Создаются вкладки для каждого файла
5. Загружаются записи первого файла

#### 2. Управление сессиями

**Создание сессии:**
1. Создается каталог `EDIT/YYYYMMDD_HHMM/`
2. Копируются все файлы из `SPOD/`
3. Сессия добавляется в список
4. Автоматически выбирается как текущая

**Переключение сессии:**
1. Меняется `current_edit_dir` в `FileManager`
2. Перезагружаются данные
3. Обновляется интерфейс

**Удаление сессии:**
1. Проверяется что сессия не текущая
2. Удаляется каталог со всеми файлами
3. Обновляется список сессий

#### 3. Работа с данными

**Чтение записей:**
- Пагинация (по умолчанию 50 записей на страницу)
- Поиск по всем полям или по конкретному полю (`field:value`)
- Сортировка по колонкам
- Сохранение порядка колонок из исходного файла

**Редактирование записи:**
1. Загружается запись по ID
2. Отображается форма с полями
3. JSON поля отображаются в специальном редакторе
4. При сохранении проверяются зависимости
5. Обновляется файл в текущей сессии

**Создание записи:**
1. Отображается пустая форма
2. Заполняются обязательные поля
3. Проверяются зависимости
4. Добавляется запись в конец файла

**Удаление записи:**
1. Проверяются зависимости (если запись используется в других файлах)
2. Показывается предупреждение
3. Удаляется запись из файла

#### 4. Обработка JSON полей

**Определение JSON полей:**
```python
JSON_FIELDS = {
    "CONTEST-DATA": ["CONTEST_FEATURE", "CONTEST_PERIOD", "BUSINESS_BLOCK"],
    "TOURNAMENT-SCHEDULE": ["TARGET_TYPE", "FILTER_PERIOD_ARR"],
    "INDICATOR": ["INDICATOR_FILTER"],
    "GROUP": ["GROUP_VALUE"],
    "REWARD": ["REWARD_ADD_DATA"]
}
```

**Редактирование JSON:**
- Отдельный редактор для JSON полей
- Валидация JSON структуры
- Поддержка зависимостей (например, структура `REWARD_ADD_DATA` зависит от `REWARD_TYPE`)
- Автодополнение полей и значений

#### 5. Зависимости между файлами

```python
FILE_DEPENDENCIES = {
    "GROUP": {"parent": "CONTEST-DATA", "parent_key": "CONTEST_CODE", "child_key": "CONTEST_CODE"},
    "INDICATOR": {"parent": "CONTEST-DATA", "parent_key": "CONTEST_CODE", "child_key": "CONTEST_CODE"},
    "REWARD-LINK": {"parent": "REWARD", "parent_key": "REWARD_CODE", "child_key": "REWARD_CODE"},
    # ...
}
```

При удалении записи проверяется:
- Используется ли она в дочерних файлах
- Показывается список зависимых записей
- Предлагается удалить зависимые записи

### Логирование админ-панели

**Серверные логи:**
- Формат: `LOGS_DEBUG_admin_panel_YYYYMMDD_HHMM.log`
- Расположение: `LOGS/`
- Уровни: DEBUG (файл), INFO (консоль)

**Клиентские логи:**
- Консоль браузера (F12)
- Логирование всех API запросов
- Детали ошибок

---

## Техническое задание

### Требования к main.py

1. **Чтение данных:**
   - Поддержка CSV с разделителем ";"
   - Кодировка UTF-8
   - Автоматическое определение файлов по дате

2. **Обработка данных:**
   - Объединение данных по правилам `MERGE_FIELDS`
   - Проверка дубликатов по правилам `CHECK_DUPLICATES`
   - Сохранение исходного порядка колонок

3. **Запись результатов:**
   - Excel файл с несколькими листами
   - Цветовая маркировка дубликатов
   - Сохранение всех исходных данных

4. **Логирование:**
   - DEBUG уровень в файл
   - INFO уровень в консоль
   - Формат с указанием функции

### Требования к админ-панели

1. **Функциональность:**
   - Просмотр всех файлов через вкладки
   - CRUD операции для всех записей
   - Редактирование JSON полей
   - Управление сессиями редактирования

2. **Интерфейс:**
   - Современный дизайн
   - Адаптивная верстка
   - Удобная навигация

3. **Валидация:**
   - Проверка обязательных полей
   - Проверка зависимостей
   - Валидация JSON

4. **Безопасность:**
   - Работа только с копиями файлов
   - Резервное копирование
   - Изоляция сессий

---

## Анализ входных данных

### Структура файлов

Все файлы имеют структуру CSV с разделителем ";" и кодировкой UTF-8.

### JSON поля

В 5 файлах обнаружено 8 JSON полей:

1. **CONTEST-DATA:**
   - `CONTEST_FEATURE` - объект с признаками конкурса
   - `CONTEST_PERIOD` - массив периодов
   - `BUSINESS_BLOCK` - массив строк

2. **TOURNAMENT-SCHEDULE:**
   - `TARGET_TYPE` - объект с `seasonCode`
   - `FILTER_PERIOD_ARR` - массив объектов

3. **INDICATOR:**
   - `INDICATOR_FILTER` - массив объектов

4. **GROUP:**
   - `GROUP_VALUE` - массив чисел или строка

5. **REWARD:**
   - `REWARD_ADD_DATA` - объект (структура зависит от `REWARD_TYPE`)

### Зависимости между файлами

- **GROUP** → **CONTEST-DATA** (по `CONTEST_CODE`)
- **INDICATOR** → **CONTEST-DATA** (по `CONTEST_CODE`)
- **TOURNAMENT-SCHEDULE** → **CONTEST-DATA** (по `CONTEST_CODE`)
- **REPORT** → **TOURNAMENT-SCHEDULE** (по `TOURNAMENT_CODE`, `CONTEST_CODE`)
- **REWARD-LINK** → **REWARD** (по `REWARD_CODE`)
- **REWARD-LINK** → **CONTEST-DATA** (по `CONTEST_CODE`)
- **REWARD-LINK** → **GROUP** (по `CONTEST_CODE`, `GROUP_CODE`)

### Многострочные поля

- **REWARD-LINK.GROUP_CODE** - список значений через запятую

---

## Установка и запуск

### Требования

- Python 3.8+ (рекомендуется 3.10)
- pip (для базового Python) или conda (для Anaconda)
- Виртуальное окружение (рекомендуется)

### Зависимости main.py: базовый Python и Anaconda 3.10

Код использует только стандартную библиотеку Python (os, sys, json, re, csv, logging, datetime, typing, concurrent.futures, threading, inspect и др.) плюс **внешние пакеты**:

| Пакет     | Назначение                    | Базовый Python 3.10 | Anaconda 3.10      |
|-----------|-------------------------------|----------------------|--------------------|
| **pandas**| DataFrame, чтение/обработка CSV| ❌ ставить вручную   | ✅ входит в base   |
| **openpyxl** | Запись Excel, стили, форматирование | ❌ ставить вручную | ✅ обычно в base   |
| **numpy** | Векторизованный расчёт статуса турнира (`np.select`) | ❌ (ставится с pandas) | ✅ входит в base |

- **Базовый Python 3.10** (с python.org): внешних библиотек **нет** в поставке. Нужна установка: `pip install -r requirements.txt` (или минимум `pip install pandas openpyxl`).
- **Anaconda 3.10**: в базовое окружение уже входят numpy, pandas и, как правило, openpyxl. Код **работает без дополнительной установки**. Если чего-то не хватает: `conda install pandas openpyxl`.

В `tournament.py` и `main_impl.py` при отсутствии numpy используется запасной вариант на чистом pandas (медленнее, но без numpy).

### Установка и запуск main.py

Запуск выполняется **из корня проекта** (каталог, где лежат `main.py` и `config.json`). Конфигурация читается из `config.json` в корне; входные CSV — из каталога, заданного в `paths.input` (по умолчанию `SPOD/`).

```bash
# Создание виртуального окружения (рекомендуется)
python3 -m venv venv
source venv/bin/activate  # Linux/macOS
# или: venv\Scripts\activate  # Windows

# Установка зависимостей (из корня проекта)
pip install -r requirements.txt
# или вручную: pip install pandas openpyxl

# Запуск из корня проекта
python main.py
```

Выходной Excel создаётся в каталоге `paths.output` (по умолчанию `OUT/`), логи — в `paths.logs` (по умолчанию `LOGS/`).

### Установка админ-панели

```bash
# Переход в каталог админ-панели
cd admin_panel

# Создание виртуального окружения (если нужно)
python3 -m venv venv
source venv/bin/activate

# Установка зависимостей
pip install -r requirements.txt

# Запуск
python app.py
# или
./start.sh
```

Админ-панель будет доступна по адресу: `http://localhost:5001`

---

## Логирование

### Формат логов

**DEBUG уровень (в файл):**
```
2025-11-14 03:02:51,034 | DEBUG | __main__ | <module> | Запуск сервера админ-панели... [class: None | def: <module>]
```

**INFO уровень (в консоль):**
```
2025-11-14 03:02:51,034 | INFO | __main__ | <module> | Запуск сервера админ-панели...
```

### Именование файлов логов

- `main.py`: `LOGS_DEBUG_YYYYMMDD_HH_MM.log`
- `admin_panel`: `LOGS_DEBUG_admin_panel_YYYYMMDD_HHMM.log`

### Расположение

Все логи сохраняются в каталоге `LOGS/`

---

## История версий

### Версия 1.1 — Модульная структура и классы (обновление документации)

**Документация:**
- В содержание добавлен раздел «Модули src/ (описание и назначение)» с таблицей модулей, их назначением и перечнем основных классов и функций.
- Раздел «Программа main.py» обновлён: описание точки входа (корневой main.py → Config → main_impl.main()), инициализации и чтения CSV.
- Раздел «Установка и запуск» уточнён: запуск из корня проекта, использование `requirements.txt`, каталоги OUT/ и LOGS/.
- В структуру проекта добавлен файл `requirements.txt`.

**Изменения кода (v1.1):**
- **Точка входа**: корневой `main.py` только загружает конфигурацию (`Config`), внедряет её в контекст и запускает пайплайн из `src.main_impl`.
- **Каталог src/**: весь рабочий код вынесен в модули:
  - `config_loader.py` — класс `Config` (загрузка config.json, атрибуты для путей, листов, правил merge, валидации и т.д.).
  - `config_holder.py` — внедрение текущего конфига для совместимости с `main_impl`.
  - `logging_setup.py` — форматтер логов с именем функции, настройка логгера по конфигу.
  - `json_utils.py` — разбор и разворот JSON-полей (`safe_json_loads`, `flatten_json_column_recursive`).
  - `file_loader.py` — класс `FileLoader`: поиск файлов без учёта регистра, чтение CSV, разворот JSON по конфигу.
  - `tournament.py` — расчёт статуса турнира (`calculate_tournament_status` по датам и config).
  - `validation.py` — валидация длины полей и проверка дубликатов (в т.ч. векторизованные и параллельные варианты).
  - `gender.py` — определение пола по отчеству/имени/фамилии (паттерны из config).
  - `main_impl.py` — полный пайплайн (загрузка CSV, merge, summary, запись Excel, отчёты); при запуске из корня использует внедрённый `Config`.
- Логика работы программы сохранена; запуск из корня: `python main.py`.

### Версия 1.0

**Основные изменения:**
- Реализована основная программа обработки данных (`main.py`)
- Вся конфигурация вынесена в **config.json** (пути, input_files, summary_sheet, sheet_order, summary_key_defs, gender, field_length_validations, derived_columns, merge_fields_advanced, color_scheme, column_formats, check_duplicates, json_columns)
- **sheet_order** в config — задаётся порядок листов в выходном Excel; листы не из списка идут следом по алфавиту
- Лист **STAT_FILE** — сводная статистика по исходным файлам (имя файла, лист, дата файла, дата обработки, строки, колонки, размер, статус)
- Создана админ-панель для редактирования данных
- Настроено логирование с двумя уровнями
- Реализована проверка дубликатов по правилам из config
- Итоговая статистика по дубликатам и отклонениям длины полей в лог и консоль в конце работы (без прерывания)
- Добавлена поддержка JSON полей (разворот по json_columns)
- Реализовано управление сессиями редактирования
- **derived_columns** — производные колонки на листе (например, табельный в 20 знаков с лидирующими нулями на LIST-REWARDS); **src_key_transforms** / **dst_key_transforms** в merge — преобразование ключей при связке (pad_20 и т.д.)
- Документация собрана в корневом README.md и каталоге Docs/; копии main.py, README.md, config.json сохраняются в POST/ с суффиксом .txt

**Исправленные проблемы:**
- Исправлены отступы в main.py (basedpyright): find_file_case_insensitive, safe_json_loads, generate_dynamic_color_scheme_from_merge_fields, merge_fields_across_sheets
- Исправлен порядок колонок в админ-панели
- Добавлено детальное логирование ошибок
- Исправлена обработка JSON полей
- Улучшена валидация данных
- Исправлена работа с зависимостями между файлами

**Оптимизации:**
- Удалены неиспользуемые функции создания SUMMARY листов
- Улучшена производительность чтения CSV
- Оптимизирована работа с большими файлами

---

## Контакты и поддержка

Для вопросов и предложений обращайтесь к разработчику проекта.

---

*Документация обновлена: 2026-02-06*
