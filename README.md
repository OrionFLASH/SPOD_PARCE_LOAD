
---

# SPOD PROM DATA TOOL

## Описание

**SPOD PROM DATA TOOL** — профессиональный Python-инструмент для автоматизированной интеграции, сверки, агрегации и анализа отчётных выгрузок по конкурсам, наградам и показателям. Позволяет гибко объединять любые источники, формировать универсальные сводные таблицы с подгрузкой любых полей по одиночным и составным ключам, разворачивать вложенные JSON-структуры любой глубины, а также обеспечивает прозрачное и масштабируемое логирование.

---

## Основные функциональные возможности

* **Автоматическая загрузка** произвольного набора CSV-файлов по единому конфигу.
* **Итоговый лист SUMMARY** с гибкой подгрузкой полей по ключам любой сложности.
* **Универсальные объединения (join)** по ключам (любое число ключей, любая комбинация).
* **Автоматическое разворачивание вложенных JSON-полей** с поддержкой любого уровня вложенности и пользовательскими префиксами.
* **Вложенное разворачивание**: например, поле `ADD_DATA => getCondition` внутри REWARD\_ADD\_DATA, а также любые вложенные структуры внутри getCondition (`nonRewards`, `employeeRating` и др.).
* **Гибкая архитектура конфигурации**: вся логика (структура файлов, join, агрегация) задаётся в переменных-конфигах — ни одна функция не требует изменений при добавлении новых связей/листов.
* **Подробное унифицированное логирование** с контролем уровня и шаблонными сообщениями, поддержка append логов по дате.
* **Кроссплатформенность**: поддержка путей для MacOS, Linux и Windows (рекомендуется использовать raw-string или /).

---

## Структура проекта

```
main.py
DIR_INPUT/
    (CSV-файлы)
DIR_OUTPUT/
    (Excel-отчёты)
DIR_LOGS/
    (логи исполнения)
```

---

## Основные переменные и константы

### INPUT\_FILES

Массив словарей: каждый элемент задаёт параметры для одного файла (имя, имя листа, ширина колонок, область закрепления).

```python
INPUT_FILES = [
    {
        "file": "CONTEST-DATA (PROM) 2025-07-14 v0",
        "sheet": "CONTEST-DATA",
        "max_col_width": 120,
        "freeze": "C2"
    },
    ...
]
```

— количество, имена и параметры файлов настраиваются свободно.

---

### SUMMARY\_SHEET

Параметры итогового листа (имя, ширина, freeze):

```python
SUMMARY_SHEET = {
    "sheet": "SUMMARY",
    "max_col_width": 70,
    "freeze": "F2"
}
```

---

### SUMMARY\_MERGE\_FIELDS

Список join-правил для SUMMARY: для каждого поля указывается источник (`sheet`), ключ(и) в источнике (`src_key`), ключ(и) в итоговой таблице (`dst_key`), имя/список полей (`column`).
**Любое количество join-правил.**

```python
SUMMARY_MERGE_FIELDS = [
    {
        "sheet": "CONTEST-DATA",
        "src_key": ["CONTEST_CODE"],
        "dst_key": ["CONTEST_CODE"],
        "column": "FULL_NAME"
    },
    {
        "sheet": "GROUP",
        "src_key": ["CONTEST_CODE", "GROUP_CODE"],
        "dst_key": ["CONTEST_CODE", "GROUP_CODE"],
        "column": ["GET_CALC_CRITERION", "ADD_CALC_CRITERION"]
    },
    ...
]
```

---

### Логирование

* **LOG\_LEVEL** — уровень (`"DEBUG"` или `"INFO"`).
* **LOG\_MESSAGES** — словарь шаблонов для унификации логов.
* Каждый запуск пишет лог в файл по дате (`LOGS_YYYY-MM-DD.log`) — старые логи не затираются, записи накапливаются.

---

## Основные функции

### setup\_logger()

Инициализирует logging: выводит в файл и консоль, имя файла включает дату (`YYYY-MM-DD`), режим — дописывание.
*Если функция уже инициализирована — не добавляет хэндлеры повторно.*

---

### read\_csv\_file(file\_path)

Загружает CSV-файл с разделителем `;`, кодировка `utf-8`, все поля — строки.
Логирует успешную загрузку и ошибки.

---

### flatten\_json\_column(df, column, prefix, ...)

Разворачивает JSON в заданной колонке DataFrame, создаёт новые колонки по ключам (с нужным префиксом).
**Особенности:**

* поддержка вложенных JSON;
* обработка списков, вложенных словарей;
* расширенное логирование структуры.

---

### flatten\_nested\_json\_column(df, source\_col, prefix, subfield, ...)

Разворачивает вложенное поле (`subfield`) внутри JSON-строки в колонке `source_col` (например, `nonRewards` в `getCondition`).
Создаёт отдельные колонки для всех ключей в этом под-объекте.

---

### enrich\_reward\_with\_contest\_code(df\_reward, df\_link)

Добавляет к DataFrame REWARD колонку `REWARD_LINK =>CONTEST_CODE`, найденную по REWARD\_CODE через REWARD-LINK.

---

### add\_fields\_to\_sheet(df\_base, df\_ref, src\_keys, dst\_keys, columns, ...)

Универсально добавляет (join'ит) новые поля из одного датафрейма в другой по любому количеству ключей и любой комбинации полей.
**Не требует изменений под новые поля или связи.**

---

### build\_summary\_sheet(dfs, params\_summary, merge\_fields)

Главная функция по построению SUMMARY:

* формирует каркас по всем комбинациям ключей;
* подгружает все требуемые поля по правилам;
* подробный лог, поддержка масштабирования.

---

### write\_to\_excel(sheets\_data, output\_path)

Записывает все датафреймы на отдельные листы Excel, применяет форматирование, закрепление, порядок листов.

---

### main()

**Пошаговый сценарий:**

1. Настройка логирования.
2. Загрузка файлов в DataFrame.
3. Разворачивание всех JSON-полей (в том числе вложенных, с любым уровнем).
4. Подгрузка дополнительных колонок (например, REWARD\_LINK => CONTEST\_CODE).
5. Формирование итогового листа по гибким join-правилам.
6. Запись результата в Excel.
7. Финальный лог с деталями по времени, числу строк, файлам.

---

## Пример работы с вложенным JSON

**REWARD\_ADD\_DATA** содержит JSON с полем `getCondition`, внутри которого также JSON (например, `nonRewards`, `employeeRating`).
Скрипт развернёт:

* все ключи `ADD_DATA => ...` (из REWARD\_ADD\_DATA)
* все ключи `ADD_DATA => getCondition => ...`
* все ключи внутри `ADD_DATA => getCondition => nonRewards => ...`
* все ключи внутри `ADD_DATA => getCondition => employeeRating => ...`

**Пример:**

| REWARD\_ADD\_DATA                                                    | ... |
| -------------------------------------------------------------------- | --- |
| {"getCondition": "{"nonRewards": {"blocked": "Y"}, "reason": "OK"}"} | ... |

На выходе появятся поля:

* `ADD_DATA => getCondition => reason`
* `ADD_DATA => getCondition => nonRewards => blocked`

---

## Пример вызова

```bash
python main.py
```

Результат: Excel-файл в `DIR_OUTPUT` и лог-файл в `DIR_LOGS`.

---

## Добавление новых связей, вложенных полей, листов

1. Описать новый источник или лист в `INPUT_FILES`.
2. Описать новый join (или несколько) в `SUMMARY_MERGE_FIELDS` — ничего больше менять не требуется.
3. Для вложенных JSON-структур добавить вызов `flatten_json_column` или `flatten_nested_json_column` в блоке main (см. пример разворачивания getCondition/employeeRating).

---

## Версии и изменения

* **v1.0** — базовая агрегация, Excel-вывод.
* **v1.1** — разворачивание JSON.
* **v1.2** — генерация SUMMARY по ключам.
* **v1.3** — универсальные join'ы.
* **v1.4** — расширяемая архитектура, логирование, форматирование.
* **v1.5** — кроссплатформенность, новые правила объединения, стабильность, обработка отсутствующих ключей.
* **v1.6** (текущая):

  * Полная поддержка вложенных JSON (getCondition, nonRewards, employeeRating и пр.).
  * Новая структура логирования: лог-файлы по дате, режим append.
  * Универсальный алгоритм сбора всех возможных комбинаций ключей.
  * Любая глубина вложенности без изменений функций.
  * Упрощённое масштабирование — добавление новых связей и файлов в одну строчку.

---

## Требования

* Python 3.8+
* pandas
* openpyxl

---

## Техническое задание (актуальная редакция)

1. Программа читает файлы из INPUT\_FILES, разворачивает вложенные JSON-структуры любого уровня.
2. Итоговый лист строится по гибко настраиваемым правилам SUMMARY\_MERGE\_FIELDS.
3. Логика подгрузки не требует изменений функций — только добавление/изменение описаний join-правил.
4. Лог-файлы ведутся по дате и накапливают все логи всех запусков за день.
5. Все действия (от загрузки, до join и записи Excel) логируются по унифицированным шаблонам.
6. Для отсутствующих данных всегда выводится "-".
7. Поддерживается работа на MacOS, Linux, Windows, любые абсолютные/относительные пути.

---
