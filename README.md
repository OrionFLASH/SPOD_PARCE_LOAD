
---

# SPOD PROM DATA TOOL

## Описание

**SPOD PROM DATA TOOL** — профессиональный Python-инструмент для интеграции, сверки и агрегации отчетных выгрузок по конкурсам, наградам и показателям. Позволяет автоматически собирать сводные таблицы, гибко объединять данные по одиночным и составным ключам, разворачивать вложенные JSON-поля, настраивать подгрузку любых полей и обеспечивает прозрачное логирование на всех этапах работы.

---

## Функциональные возможности

* **Автоматическая загрузка** множества CSV-файлов по единому конфигу.
* **Формирование итогового листа** (SUMMARY) с гибкой подгрузкой любых полей по ключам/составным ключам.
* **Универсальное объединение данных** (join) по ключам из разных источников, в том числе с поддержкой сложных (многокомпонентных) ключей.
* **Разворачивание JSON-колонок**: автоматическое добавление вложенных структур в виде отдельных колонок с префиксами.
* **Гибкая конфигурация** через переменные (INPUT\_FILES, SUMMARY\_MERGE\_FIELDS, SUMMARY\_SHEET).
* **Подробное логирование** на каждом этапе с унифицированными шаблонами сообщений, детализированная отладка.
* **Кроссплатформенность**: поддержка абсолютных путей в стиле Mac/Linux и Windows (рекомендуется raw-string или прямой /-разделитель).
* **Масштабируемость**: не требует изменения функций для добавления новых связей, полей и листов.

---

## Структура файлов и папок

* **main.py** — основной исполняемый скрипт.
* **DIR\_INPUT/** — папка с входными файлами (.CSV).
* **DIR\_OUTPUT/** — итоговые Excel-файлы.
* **DIR\_LOGS/** — логи исполнения.

---

## Основные переменные

### INPUT\_FILES

Массив словарей, каждый из которых задаёт параметры загрузки конкретного файла:

```python
INPUT_FILES = [
    {
        "file": "CONTEST-DATA (PROM) 2025-07-14 v0", # Имя файла без расширения
        "sheet": "CONTEST-DATA",                     # Имя листа Excel
        "max_col_width": 120,                        # Максимальная ширина колонки на листе
        "freeze": "C2"                               # Ячейка закрепления для Excel
    },
    ...
]
```

*Можно указывать любое количество файлов, каждый будет прочитан и обработан.*

---

### SUMMARY\_SHEET

Параметры итогового листа, на котором собирается сводная информация:

```python
SUMMARY_SHEET = {
    "sheet": "SUMMARY",         # Имя итогового листа
    "max_col_width": 70,        # Максимальная ширина колонок
    "freeze": "D2"              # Ячейка закрепления
}
```

---

### SUMMARY\_MERGE\_FIELDS

Список правил для подгрузки полей на итоговый SUMMARY-лист.
Каждый элемент массива — словарь с такими ключами:

* **sheet** — имя листа-источника
* **src\_key** — список ключей в источнике (может быть один или несколько)
* **dst\_key** — список ключей на листе summary для поиска совпадений
* **column** — имя поля для подгрузки (или список полей)

```python
SUMMARY_MERGE_FIELDS = [
    # Пример одиночного ключа
    {
        "sheet": "CONTEST-DATA",
        "src_key": ["CONTEST_CODE"],
        "dst_key": ["CONTEST_CODE"],
        "column": "FULL_NAME"
    },
    # Пример составного ключа и нескольких полей
    {
        "sheet": "GROUP",
        "src_key": ["CONTEST_CODE", "GROUP_CODE"],
        "dst_key": ["CONTEST_CODE", "GROUP_CODE"],
        "column": ["GET_CALC_CRITERION", "ADD_CALC_CRITERION"]
    }
]
```

*Можно задавать любые комбинации ключей и подгружаемых полей — никаких изменений в функциях не требуется.*

---

### LOG\_LEVEL и LOG\_MESSAGES

* **LOG\_LEVEL** — уровень логирования (`"DEBUG"` или `"INFO"`).
* **LOG\_MESSAGES** — шаблоны сообщений для унификации всех логов, используются во всех функциях.

```python
LOG_LEVEL = "DEBUG"
LOG_MESSAGES = {
    "start":                "=== Старт работы программы: {time} ===",
    "reading_file":         "Загрузка файла: {file_path}",
    "read_ok":              "Файл успешно загружен: {file_path}, строк: {rows}, колонок: {cols}",
    "read_fail":            "Ошибка загрузки файла: {file_path}. {error}",
    "sheet_written":        "Лист Excel сформирован: {sheet} (строк: {rows}, колонок: {cols})",
    "finish":               "=== Завершение работы. Обработано файлов: {files}, строк всего: {rows_total}. Время выполнения: {time_elapsed} ===",
    "summary":              "Summary: {summary}",
    "func_start":           "[START] {func} {params}",
    "func_end":             "[END] {func} {params} (время: {time:.3f}s)",
    "func_error":           "[ERROR] {func} {params} — {error}",
    "json_flatten_start":   "Разворачивание колонки {column} (строк: {rows})",
    "json_flatten_end":     "Развёрнуто {n_cols} колонок из {n_keys} ключей, ошибок JSON: {n_errors}, строк: {rows}, время: {time:.3f}s",
    "json_flatten_error":   "Ошибка разбора JSON (строка {row}): {error}",
    "debug_columns":        "[DEBUG] {sheet}: колонки после разворачивания: {columns}",
    "debug_head":           "[DEBUG] {sheet}: первые строки после разворачивания:\n{head}",
    "field_joined":         "Колонка {column} присоединена из {src_sheet} по ключу {dst_key} -> {src_key}",
    "field_missing":        "Колонка {column} не добавлена: нет листа {src_sheet} или ключей {src_key}",
    "fields_summary":       "Итоговая структура: {rows} строк, {cols} колонок"
}
```

---

## Описание функций

### setup\_logger()

Настраивает подробное логирование: запись в файл (в папке LOGS) и вывод на экран. Автоматически создаёт уникальное имя лога с учётом даты, времени и уровня.

---

### read\_csv\_file(file\_path)

Загружает CSV-файл с заданным разделителем `;` и кодировкой `utf-8`. Возвращает pandas.DataFrame.

* **file\_path**: полный путь к файлу
* Логирует успешную загрузку или ошибку.

---

### flatten\_json\_column(df, column, prefix, sheet=None, sep="; ")

Разворачивает JSON в колонке DataFrame и создаёт отдельные колонки по ключам (с заданным префиксом).

* **df**: исходный DataFrame
* **column**: имя JSON-колонки
* **prefix**: префикс для новых полей
* **sheet**: имя листа (для лога, опционально)
* **sep**: разделитель для списков внутри JSON
  Логирует структуру новых полей и ошибки разбора.

---

### enrich\_reward\_with\_contest\_code(df\_reward, df\_link)

Добавляет к DataFrame REWARD колонку с CONTEST\_CODE, найденным по REWARD\_CODE через REWARD-LINK.
Используется для быстрой связи между наградами и конкурсами.

---

### add\_fields\_to\_sheet(df\_base, df\_ref, src\_keys, dst\_keys, columns, sheet\_name, ref\_sheet\_name)

Подгружает одно или несколько новых полей из df\_ref в df\_base по одиночным или составным ключам.

* **df\_base**: датафрейм, куда добавлять поле(я)
* **df\_ref**: источник новых полей
* **src\_keys**: список ключей в источнике
* **dst\_keys**: список ключей для поиска в df\_base
* **columns**: строка или список полей для подгрузки
* **sheet\_name**: имя листа, куда добавляем
* **ref\_sheet\_name**: лист-источник
  Функция универсальная, никаких изменений под новые связи не требует.

---

### build\_summary\_sheet(dfs, params\_summary, merge\_fields)

Главная функция по формированию итогового листа.

* Выбирает базовый датафрейм (например, CONTEST-DATA) по наличию CONTEST\_CODE.
* Подгружает все требуемые поля, описанные в merge\_fields, с поддержкой любых связей.
* Все действия логируются (добавление колонок, отсутствие данных, отладочная печать первых строк).
* Поддерживает масштабирование без модификации кода.

---

### write\_to\_excel(sheets\_data, output\_path)

Записывает все DataFrame (и их параметры) на отдельные листы итогового Excel-файла.

* Применяет форматирование (ширина колонок, перенос строк, закрепление областей).
* Логирует запись каждого листа.

---

### main()

Общий сценарий исполнения:

1. Настройка логирования.
2. Загрузка всех файлов в DataFrame.
3. Разворачивание JSON-колонок (если есть).
4. Добавление дополнительных колонок (например, REWARD\_LINK => CONTEST\_CODE).
5. Формирование итогового листа SUMMARY с join’ами по описанным правилам.
6. Запись результата в Excel.
7. Итоговый лог по количеству строк, файлов, длительности.

---

## Примеры входных данных

**CSV с JSON-полем:**

```
CONTEST_CODE;CONTEST_FEATURE
C123;{"feature":["Обучение","Оплата дороги"],"param":"yes"}
```

**Лист GROUP:**

```
CONTEST_CODE;GROUP_CODE;GET_CALC_CRITERION
C123;GRP1;Баллы за KPI
```

---

## Пример вызова

```bash
python main.py
```

Результат — Excel-файл с готовыми листами и подробный лог с таймингом.

---

## Добавление новых связей и полей

Для подгрузки новых колонок:

1. Добавьте описание связи в SUMMARY\_MERGE\_FIELDS:

```python
SUMMARY_MERGE_FIELDS += [
    {
        "sheet": "NEW_SHEET",
        "src_key": ["SOME_ID", "OTHER_KEY"],
        "dst_key": ["SOME_ID", "OTHER_KEY"],
        "column": "NEW_FIELD"
    }
]
```

2. Не требуется никаких изменений в функциях.

---

## Версии и изменения

* **v1.0** — базовый парсинг и запись в Excel.
* **v1.1** — поддержка разворачивания JSON-колонок.
* **v1.2** — построение итогового листа SUMMARY по ключу.
* **v1.3** — универсальные join’ы по одному/нескольким полям.
* **v1.4** — гибкая архитектура (SUMMARY\_MERGE\_FIELDS), расширяемое логирование, поддержка всех ключей, форматирование листов, массовая обработка.
* **v1.5** — поддержка абсолютных путей (raw-string и / для Windows/Mac), обновлённая архитектура build\_summary\_sheet, строгий контроль типов ключей, автодобавление отсутствующих ключей (GROUP\_CODE, REWARD\_CODE и др.), подробная отладка, стабильность на больших выборках.

---

## Требования

* Python 3.8+
* pandas
* openpyxl

---

## Техническое задание (актуально, итоговые требования)

1. Программа читает все файлы из INPUT\_FILES, разворачивает JSON-поля и формирует Excel-отчёт с отдельными листами.
2. Итоговый лист (SUMMARY) формируется по правилам — любые связи по ключам, любые поля, всё конфигурируется через SUMMARY\_MERGE\_FIELDS.
3. Логика подгрузки полностью конфигурируется в массиве SUMMARY\_MERGE\_FIELDS (масштабируется без изменений кода).
4. Программа формирует подробный лог исполнения (информационный и отладочный уровень).
5. Все действия (загрузка, join, добавление полей, ошибки) логируются по шаблонам LOG\_MESSAGES.
6. Для отсутствующих значений всегда выводится прочерк "-".
7. Настройка ширины колонок, freeze, порядка и имен листов — через переменные.
8. Корректная работа на Mac, Linux и Windows (рекомендуется raw-string или / для путей).

---
