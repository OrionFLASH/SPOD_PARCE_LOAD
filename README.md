
---
# SPOD PROM DATA TOOL

## Описание

**SPOD PROM DATA TOOL** — профессиональный Python-инструмент для интеграции, сверки и агрегации отчетных выгрузок по конкурсам, наградам и показателям. Автоматизирует сбор сводных таблиц, гибко объединяет данные по любым ключам (в том числе составным), разворачивает вложенные JSON-поля и обеспечивает прозрачное логирование на всех этапах.

---

## Функциональные возможности

- **Автоматическая загрузка** множества CSV-файлов по единому конфигу
- **Формирование итогового листа** (SUMMARY) с подгрузкой любых полей по ключам/составным ключам
- **Универсальное объединение данных** (join) по ключам из разных источников
- **Разворачивание JSON-колонок** в отдельные поля с префиксами
- **Гибкая конфигурация** через переменные (INPUT_FILES, SUMMARY_MERGE_FIELDS)
- **Подробное логирование** на каждом шаге с шаблонами сообщений
- **Масштабируемость** — не требует изменения функций для расширения логики

---

## Структура файлов и папок

- **main.py** — основной исполняемый скрипт
- **DIR_INPUT/** — папка входных файлов (.CSV)
- **DIR_OUTPUT/** — итоговые Excel-файлы
- **DIR_LOGS/** — логи исполнения

---

## Основные переменные

### INPUT_FILES

Массив словарей, где каждый описывает источник данных:
```python
INPUT_FILES = [
    {
        "file": "CONTEST-DATA (PROM) 2025-07-14 v0", # Имя файла без расширения
        "sheet": "CONTEST-DATA",                     # Имя листа Excel
        "max_col_width": 120,                        # Максимальная ширина колонки на листе
        "freeze": "C2"                               # Ячейка закрепления для Excel
    },
    ...
]
````

> **Важно:** Список может быть произвольной длины.

---

### SUMMARY\_SHEET

Параметры итогового листа:

```python
SUMMARY_SHEET = {
    "sheet": "SUMMARY",
    "max_col_width": 70,
    "freeze": "D2"
}
```

---

### SUMMARY\_MERGE\_FIELDS

Список правил для подгрузки полей на SUMMARY-лист. Каждый элемент:

* sheet — имя листа-источника
* src\_key — список ключевых полей в источнике
* dst\_key — список полей на листе summary для поиска совпадения
* column — имя поля для подгрузки (или список полей)

```python
SUMMARY_MERGE_FIELDS = [
    # Пример одиночного ключа
    {
        "sheet": "CONTEST-DATA",
        "src_key": ["CONTEST_CODE"],
        "dst_key": ["CONTEST_CODE"],
        "column": "FULL_NAME"
    },
    # Пример составного ключа
    {
        "sheet": "GROUP",
        "src_key": ["CONTEST_CODE", "GROUP_CODE"],
        "dst_key": ["CONTEST_CODE", "GROUP_CODE"],
        "column": ["GET_CALC_CRITERION", "ADD_CALC_CRITERION"]
    }
]
```

> Можно задавать любые комбинации ключей и полей.

---

### LOG\_LEVEL и LOG\_MESSAGES

LOG\_LEVEL — уровень логирования ("DEBUG" или "INFO").

LOG\_MESSAGES — шаблоны сообщений для логирования, используемые во всех функциях:

```python
LOG_MESSAGES = {
    "start":                "=== Старт работы программы: {time} ===",
    "reading_file":         "Загрузка файла: {file_path}",
    "read_ok":              "Файл успешно загружен: {file_path}, строк: {rows}, колонок: {cols}",
    "read_fail":            "Ошибка загрузки файла: {file_path}. {error}",
    "sheet_written":        "Лист Excel сформирован: {sheet} (строк: {rows}, колонок: {cols})",
    "finish":               "=== Завершение работы. Обработано файлов: {files}, строк всего: {rows_total}. Время выполнения: {time_elapsed} ===",
    "summary":              "Summary: {summary}",
    "func_start":           "[START] {func} {params}",
    "func_end":             "[END] {func} {params} (время: {time:.3f}s)",
    "func_error":           "[ERROR] {func} {params} — {error}",
    "json_flatten_start":   "Разворачивание колонки {column} (строк: {rows})",
    "json_flatten_end":     "Развёрнуто {n_cols} колонок из {n_keys} ключей, ошибок JSON: {n_errors}, строк: {rows}, время: {time:.3f}s",
    "json_flatten_error":   "Ошибка разбора JSON (строка {row}): {error}",
    "debug_columns":        "[DEBUG] {sheet}: колонки после разворачивания: {columns}",
    "debug_head":           "[DEBUG] {sheet}: первые строки после разворачивания:\n{head}"
}
```

---

## Описание функций

### setup\_logger()

Настройка логирования с записью в файл и на экран.

### read\_csv\_file(file\_path)

Загрузка CSV-файла с логированием (разделитель — `;`, кодировка utf-8). Возвращает pandas.DataFrame.

**Параметры:**

* file\_path: путь к файлу

---

### flatten\_json\_column(df, column, prefix, sheet=None, sep="; ")

Разворачивает вложенный JSON в колонке DataFrame и добавляет их как отдельные поля с заданным префиксом.

**Параметры:**

* df: исходный DataFrame
* column: имя колонки с JSON
* prefix: префикс для новых колонок
* sheet: имя листа (для логирования)
* sep: разделитель для списков

**Пример использования:**

```python
df = flatten_json_column(df, "CONTEST_FEATURE", "CONTEST_FEATURE => ", "CONTEST-DATA")
```

---

### enrich\_reward\_with\_contest\_code(df\_reward, df\_link)

Добавляет к DataFrame REWARD колонку с CONTEST\_CODE, найденным по REWARD\_CODE через REWARD-LINK.

---

### add\_fields\_to\_sheet(df\_base, df\_ref, src\_keys, dst\_keys, columns, sheet\_name, ref\_sheet\_name)

Подгружает новые поля (один или несколько) из df\_ref в df\_base по ключам. Поддерживает составные ключи.

**Параметры:**

* df\_base: DataFrame, куда добавляем
* df\_ref: DataFrame-источник
* src\_keys: список полей-ключей в источнике
* dst\_keys: список ключей для поиска в df\_base
* columns: строка или список, какие поля брать
* sheet\_name: имя листа (для логирования)
* ref\_sheet\_name: имя листа-источника

**Пример:**

```python
df_summary = add_fields_to_sheet(df_summary, df_group, ["CONTEST_CODE", "GROUP_CODE"], ["CONTEST_CODE", "GROUP_CODE"], "GET_CALC_CRITERION", "SUMMARY", "GROUP")
```

---

### build\_summary\_sheet(dfs, params\_summary, merge\_fields)

Главная функция по формированию итогового листа.

* Создаёт DataFrame с нужными ключевыми полями (обычно из CONTEST-DATA)
* Подгружает любые дополнительные поля, описанные в merge\_fields, через add\_fields\_to\_sheet
* Ведёт подробное логирование действий, включая DEBUG-вывод всех новых колонок

**Параметры:**

* dfs: словарь всех датафреймов
* params\_summary: параметры итогового листа (freeze, ширина, имя)
* merge\_fields: правила подгрузки

---

### write\_to\_excel(sheets\_data, output\_path)

Записывает все листы (DataFrame + параметры) в итоговый Excel-файл, применяя форматирование, ширину колонок и закрепление.

---

### main()

Общий сценарий исполнения:

1. Настройка логирования
2. Загрузка всех файлов в DataFrame
3. Разворачивание JSON-колонок (если есть)
4. Добавление дополнительных колонок (например, REWARD\_LINK => CONTEST\_CODE)
5. Формирование итогового листа SUMMARY с универсальными join'ами по описанным правилам
6. Запись всего результата в Excel
7. Итоговый лог

---

## Примеры входных данных

**CSV с JSON-полем:**

```
CONTEST_CODE;CONTEST_FEATURE
C123;{"feature":["Обучение","Оплата дороги"],"param":"yes"}
```

**Структура листа GROUP:**

```
CONTEST_CODE;GROUP_CODE;GET_CALC_CRITERION
C123;GRP1;Баллы за KPI
```

---

## Пример вызова

```bash
python main.py
```

Результат — Excel-файл с готовыми листами и подробный лог с таймингом.

---

## Добавление новых связей и полей

Для подгрузки новых колонок достаточно добавить запись в SUMMARY\_MERGE\_FIELDS:

```python
SUMMARY_MERGE_FIELDS += [
    {
        "sheet": "NEW_SHEET",
        "src_key": ["SOME_ID", "OTHER_KEY"],
        "dst_key": ["SOME_ID", "OTHER_KEY"],
        "column": "NEW_FIELD"
    }
]
```

*Никаких изменений в логике функций не требуется.*

---

## Версии и изменения

* **v1.0** — базовый парсинг и запись в Excel
* **v1.1** — разворачивание JSON-колонок
* **v1.2** — построение итогового листа по ключу
* **v1.3** — поддержка произвольных join'ов по одному/нескольким полям
* **v1.4** — универсализация (SUMMARY\_MERGE\_FIELDS), расширяемое логирование, все ключи поддерживаются, форматирование листов, массовая обработка

---

## Требования

* Python 3.8+
* pandas
* openpyxl

---

## Техническое задание (актуальное, итоги доработок)

1. Программа должна читать все файлы из INPUT\_FILES, разворачивать JSON-поля и формировать Excel-отчет с отдельными листами.
2. Итоговый лист (SUMMARY) должен содержать любые требуемые связи — по одиночным или составным ключам, с любым количеством полей.
3. Логика подгрузки полей определяется в массиве SUMMARY\_MERGE\_FIELDS (масштабируется без изменений кода).
4. Программа обязана выдавать подробный лог исполнения (информационный и отладочный уровень).
5. Все действия (загрузка, join, добавление полей, ошибки) логируются по шаблонам из LOG\_MESSAGES.
6. Для отсутствующих значений выводится прочерк "-".
7. Поддержка настройки ширины колонок, freeze, порядка и имен листов через переменные.

---

## Контакты и поддержка

Вопросы по внедрению, масштабированию и кастомизации — обращаться к автору проекта.

---