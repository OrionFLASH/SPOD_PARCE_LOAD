# Описание формирования исходного списка строк в Summary листе

## Дата анализа
2025-12-25

## Колонки Summary листа
Исходный каркас Summary листа формируется из следующих ключевых колонок:
- **CONTEST_CODE** - код конкурса
- **TOURNAMENT_CODE** - код турнира
- **REWARD_CODE** - код награды
- **GROUP_CODE** - код группы
- **GROUP_VALUE** - значение группы

Эти колонки определяются в константе `SUMMARY_KEY_DEFS` на основе ключевых полей из различных листов.

---

## Функция формирования: `collect_summary_keys()`

Функция `collect_summary_keys(dfs)` создает все возможные комбинации ключей из исходных таблиц. 
Она работает в **4 этапа**, каждый из которых обрабатывает определенный тип кода как отправную точку.

### Исходные данные
Функция использует следующие таблицы:
- `REWARD-LINK` - связи наград с конкурсами
- `TOURNAMENT-SCHEDULE` - расписание турниров
- `GROUP` - группы
- `REWARD` - награды

---

## Этап 1: Для каждого CONTEST_CODE

**Логика:**
1. Берется каждый уникальный `CONTEST_CODE` из всех таблиц (REWARD-LINK, TOURNAMENT-SCHEDULE, GROUP)
2. Для каждого `CONTEST_CODE` находятся:
   - Все связанные `TOURNAMENT_CODE` из TOURNAMENT-SCHEDULE
   - Все связанные `REWARD_CODE` из REWARD-LINK
   - Все связанные `GROUP_CODE` из GROUP
   - Все связанные `GROUP_VALUE` из GROUP
3. Если какой-то код отсутствует, используется `"-"`
4. Создаются **все возможные комбинации** этих значений через вложенные циклы:
   ```
   для каждого TOURNAMENT_CODE:
       для каждого REWARD_CODE:
           для каждого GROUP_CODE:
               для каждого GROUP_VALUE:
                   создать строку (CONTEST_CODE, TOURNAMENT_CODE, REWARD_CODE, GROUP_CODE, GROUP_VALUE)
   ```

**Пример:**
Если есть:
- CONTEST_CODE = "C1"
- TOURNAMENT_CODE = ["T1", "T2"]
- REWARD_CODE = ["R1"]
- GROUP_CODE = ["G1"]
- GROUP_VALUE = ["V1", "V2"]

То создадутся строки:
- (C1, T1, R1, G1, V1)
- (C1, T1, R1, G1, V2)
- (C1, T2, R1, G1, V1)
- (C1, T2, R1, G1, V2)

---

## Этап 2: Для каждого TOURNAMENT_CODE (даже если нет CONTEST_CODE)

**Логика:**
1. Берется каждый уникальный `TOURNAMENT_CODE` из TOURNAMENT-SCHEDULE
2. Для каждого `TOURNAMENT_CODE`:
   - Ищется связанный `CONTEST_CODE` (если нет - используется `"-"`)
   - Находятся все связанные `REWARD_CODE` по найденному `CONTEST_CODE`
   - Находятся все связанные `GROUP_CODE` и `GROUP_VALUE` по найденному `CONTEST_CODE`
3. Создаются все комбинации через вложенные циклы:
   ```
   для каждого REWARD_CODE:
       для каждого GROUP_CODE:
           для каждого GROUP_VALUE:
               создать строку (CONTEST_CODE, TOURNAMENT_CODE, REWARD_CODE, GROUP_CODE, GROUP_VALUE)
   ```

**Особенность:** Этот этап гарантирует, что каждый турнир будет представлен в Summary, даже если у него нет связанного конкурса.

---

## Этап 3: Для каждого REWARD_CODE (даже если нет CONTEST_CODE)

**Логика:**
1. Берется каждый уникальный `REWARD_CODE` из:
   - REWARD-LINK (связи)
   - **REWARD** (все награды, включая "осиротевшие" - без связей)
2. Для каждого `REWARD_CODE`:
   - Ищется связанный `CONTEST_CODE` из REWARD-LINK (если нет - используется `"-"`)
   - Ищутся связанные `TOURNAMENT_CODE` по найденному `CONTEST_CODE`
   - Ищутся связанные `GROUP_CODE` и `GROUP_VALUE` по найденному `CONTEST_CODE`
3. Создаются все комбинации через вложенные циклы:
   ```
   для каждого TOURNAMENT_CODE:
       для каждого GROUP_CODE:
           для каждого GROUP_VALUE:
               создать строку (CONTEST_CODE, TOURNAMENT_CODE, REWARD_CODE, GROUP_CODE, GROUP_VALUE)
   ```

**Особенность:** Этот этап гарантирует, что **каждая награда** будет представлена в Summary, даже если у неё нет связей с конкурсами (осиротевшие награды).

---

## Этап 4: Для каждого GROUP_CODE (даже если нет CONTEST_CODE)

**Логика:**
1. Берется каждый уникальный `GROUP_CODE` из GROUP
2. Для каждого `GROUP_CODE`:
   - Ищется связанный `CONTEST_CODE` (если нет - используется `"-"`)
   - Ищутся связанные `TOURNAMENT_CODE` по найденному `CONTEST_CODE`
   - Ищутся связанные `REWARD_CODE` по найденному `CONTEST_CODE`
   - Находятся все `GROUP_VALUE` для данного `GROUP_CODE`
3. Создаются все комбинации через вложенные циклы:
   ```
   для каждого TOURNAMENT_CODE:
       для каждого REWARD_CODE:
           для каждого GROUP_VALUE:
               создать строку (CONTEST_CODE, TOURNAMENT_CODE, REWARD_CODE, GROUP_CODE, GROUP_VALUE)
   ```

**Особенность:** Этот этап гарантирует, что каждая группа будет представлена в Summary, даже если у неё нет связанного конкурса.

---

## Финальная обработка

После всех 4 этапов:
1. Все созданные строки объединяются в список `all_rows`
2. Создается DataFrame с колонками `SUMMARY_KEY_COLUMNS`
3. Удаляются дубликаты через `.drop_duplicates()`
4. Индексы сбрасываются через `.reset_index(drop=True)`

---

## Важные особенности

### 1. Обработка отсутствующих значений
- Если какой-то код отсутствует, используется значение `"-"`
- Это гарантирует, что все комбинации будут созданы, даже при неполных данных

### 2. Декартово произведение
- На каждом этапе создаются **все возможные комбинации** значений
- Это означает, что если есть N турниров, M наград, K групп и L значений групп, 
  то для одного конкурса может быть создано N × M × K × L строк

### 3. Осиротевшие коды
- Функция специально обрабатывает коды, которые не имеют связей:
  - Турниры без конкурсов (этап 2)
  - Награды без конкурсов (этап 3)
  - Группы без конкурсов (этап 4)

### 4. Учет всех источников
- `REWARD_CODE` собирается из **двух источников**:
  - REWARD-LINK (связи)
  - REWARD (все награды)
- Это гарантирует, что даже награды без связей попадут в Summary

---

## Пример формирования

### Исходные данные:

**REWARD-LINK:**
```
REWARD_CODE | CONTEST_CODE
R1          | C1
R2          | C1
R3          | C2
```

**TOURNAMENT-SCHEDULE:**
```
TOURNAMENT_CODE | CONTEST_CODE
T1              | C1
T2              | C1
T3              | C3
```

**GROUP:**
```
GROUP_CODE | CONTEST_CODE | GROUP_VALUE
G1         | C1          | V1
G1         | C1          | V2
G2         | C2          | V3
```

**REWARD:**
```
REWARD_CODE
R1
R2
R3
R4  (осиротевшая награда, нет в REWARD-LINK)
```

### Результат формирования:

**Этап 1 (по CONTEST_CODE):**
- Для C1: T1, T2 × R1, R2 × G1 × V1, V2 = 8 строк
- Для C2: (нет турниров) × R3 × (нет групп) = 1 строка
- Для C3: T3 × (нет наград) × (нет групп) = 1 строка

**Этап 2 (по TOURNAMENT_CODE):**
- Для T3: C3 × R1, R2, R3, R4 × (нет групп) = 4 строки

**Этап 3 (по REWARD_CODE):**
- Для R4 (осиротевшая): "-" × (нет турниров) × (нет групп) = 1 строка

**Этап 4 (по GROUP_CODE):**
- Для G2: C2 × (нет турниров) × R3 × V3 = 1 строка

**Итого:** После удаления дубликатов получится итоговый набор строк Summary.

---

## Выводы

1. **Исходный каркас Summary** формируется как **декартово произведение** всех возможных комбинаций ключей
2. **4 этапа обработки** гарантируют, что все коды будут представлены, даже без связей
3. **Осиротевшие коды** специально обрабатываются для полноты данных
4. **Дубликаты удаляются** в конце, но могут создаваться на разных этапах
5. **Итоговый DataFrame** содержит все уникальные комбинации ключей, которые затем дополняются данными из других листов через `merge_fields`
